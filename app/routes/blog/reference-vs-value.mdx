---
title: "Reference and Value: Why you should know the difference"
portugueseVersion: "referencia-vs-valor"
posted: "5 25 2022 17:26"
edited: "5 25 2022 17:26"
mainImage: "https://images.unsplash.com/photo-1512998844734-cd2cca565822?crop=entropy&cs=tinysrgb&fm=jpg&ixlib=rb-1.2.1&q=80&raw_url=true&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1921"
language: "EN"
tags: "JavaScript"
readTime: "3"
link: "referencia-vs-valor"
---

import Code from "../../components/Code";
import Highlight from "../../components/Highlight";
import { Link } from "@remix-run/react";
import mainImage from "~/public/images/referencevsvalue.jpg"

## {attributes.title}

<Link to={`/blog/${attributes.portugueseVersion}`}><div>Artigo em PortuguÃªs</div></Link>

<img src={mainImage} alt="" title="Photo by Duy Thanh Nguyen" className="MainImage" />

If for some reason you've tried comparing <Code>objects</Code> or <Code>arrays</Code> in JavaScript, you probably went confused by why they weren't the same even having an identical value/content.. <br/>

This happens because JavaScript compares non-primitive types with their <Highlight>reference</Highlight> and not their actual value, and not knowing that, can cause a headache.

### Copy by Value <br/>

Primitive data types like <Code>String</Code>, <Code>Number</Code>, <Code>Boolean</Code>, <Code>undefined</Code>, <Code>null</Code>, are tagged as <Highlight>Value</Highlight> types, because, when we throw its information or value in some other variable, this new variable will copy its value.

See the following example.

```js
let ğŸ = "Apple"
let ğŸ’° = 0

let ğŸ = ğŸ // "Apple"
let ğŸ‘œ = ğŸ’° // 0

console.log(ğŸ === ğŸ) // true
console.log(ğŸ‘œ === ğŸ’°) // true

```

When comparing the new variables using <Code>console.log()</Code>, it will return <Code>true</Code>, because JavaScript compares the primitives according to their content.

### Copy by Reference

On the other hand, the non-primitives, <Code>Arrays</Code>, <Code>Objects</Code>, and <Code>Functions</Code>, are tagged as <Highlight>Reference</Highlight> types. Because, when we define a new variable with its information, this new variable will have its reference and not its value.

<br />
See the following example

```js
const ğŸš— = [ğŸ’º, ğŸ’º, ğŸ’º, ğŸ’º]
const ğŸš“ = [ğŸ’º, ğŸ’º, ğŸ’º, ğŸ’º]
const ğŸš˜ = ğŸš—

console.log(ğŸš“ === ğŸš—) // false
console.log(ğŸš˜ === ğŸš—) // true
```

Let's go back to some lines in the text <Highlight>"this new variable will have its reference and not its value"</Highlight>. But, if it won't have the value, how did javascript manage to compare the ğŸš˜ with ğŸš—? And why does ğŸš“ when compared to ğŸš—, JavaScript tell us that it's "different"? <br/>

The answer is simple, comparison by <Highlight>reference</Highlight>! Primitive data types are copied and compared by value, and non-primitive ones are copied and compared by reference.

### Ok, but what is Reference?

References are addresses allocated in your computer's memory, and when we compare two non-primitive pieces of information, for example, an <Code>object</Code>, JavaScript compares its memory address and not its contents. Let's see one more example.

```js
const ğŸ‘©â€âš•ï¸ = {
  name: "Bia",
  age: 28
};

const ğŸ‘©â€ğŸ³ = ğŸ‘©â€âš•ï¸;


console.log(ğŸ‘©â€âš•ï¸.name); // Bia

ğŸ‘©â€ğŸ³.nome = "Patricia";

console.log(ğŸ‘©â€âš•ï¸.name); // Patricia
console.log(ğŸ‘©â€ğŸ³.name); // Patricia
```

When we set the name of ğŸ‘©â€ğŸ³ to Patricia, the name of ğŸ‘©â€âš•ï¸ also changes! That's because the content of ğŸ‘©â€ğŸ³ is a <Highlight>reference</Highlight> to the content of ğŸ‘©â€âš•ï¸, so whatever changes there are in any reference to the <Code>Object</Code>, <Code>Array</Code>, <Code >Function</Code> the original one will be affected.

### Why knowing this is important?

If you've been using React for a while, we have several hooks and features that help our program's performance, and an important one is the <Code>useEffect()</Code>'s dependency array. If you put an array or object as a dependency, your page will not work correctly, and that's because <Code>useEffect()</Code> is comparing non-primitives with their <Highlight>reference</Highlight>. <br/>

Another example is the <Code>useCallback()</Code>, used to memoize functions, comparing them with their content, preventing the creation of another identical function on every rendering. If you want a post talking about it, let me know!


### <Highlight>Remember!</Highlight>

	â€¢ Value types are Primitives and copied by their value. <br/>
	â€¢ Reference types are non-primitives and are copied by their reference. <br/>
  â€¢ When comparing identical non-primitives, they return <Code>false</Code> because their <Highlight>reference</Highlight> type. <br/>
  
  â€¢ Value types â†’ <Code>String</Code>, <Code>Number</Code>, <Code>Boolean</Code>, <Code>undefined</Code> and <Code>null</Code>. <br/>
  â€¢ Reference types â†’ <Code>Array</Code>, <Code>Object</Code> and <Code>Function</Code>.
