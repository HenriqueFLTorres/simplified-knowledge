---
title: "Valor e ReferÃªncia: Porque vocÃª deve saber a diferenÃ§a?"
posted: "5 20 2022"
edited: "5 20 2022"
mainImage: ""
---

## {attributes.title}

Se por algum motivo vocÃª jÃ¡ tentou comparar objetos ou arrays no javascript, vocÃª provavelmente ficou confuso do porque apesar de eles terem o mesmo valor, eles nÃ£o sÃ£o "iguais". <br/>

Isso acontece porque o javascript compara os objetos ou arrays por sua REFERENCIA e nÃ£o seu real valor, podendo causar dor de cabeÃ§a caso vocÃª nÃ£o saiba como isto funciona.<br/>

## CÃ³pia por Valor <br/>

InformaÃ§Ãµes primitivas, <code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>undefined</code>, <code>null</code>, sÃ£o chamadas assim porque ao jogarmos suas informaÃ§Ãµes ou valor em alguma outra variÃ¡vel, esta nova variÃ¡vel irÃ¡ copiar o seu valor, ou seja, sua informaÃ§Ã£o.
<br/>
Veja o exemplo a seguir

```js
let ğŸ = "MaÃ§a"
let ğŸ’° = 0

let ğŸ = ğŸ // "MaÃ§a"
let ğŸ‘œ = ğŸ’° // 0

console.log(ğŸ === ğŸ) // true
console.log(ğŸ‘œ === ğŸ’°) // true

````

  Ao compararmos as novas variÃ¡veis usando <code>console.log()</code>, ele vai nos retornar <code>true</code>, pois o javascript compara os valores primitivos de acordo com os seus valores.

## CÃ³pia por ReferÃªncia

  Por outro lado, os copiados por sua referÃªncia, <code>Arrays</code>, <code>Objetos</code> e <code>FuncÃµes</code>, ao definirmos uma nova variÃ¡vel com suas informaÃ§Ãµes, esta nova variÃ¡vel nÃ£o irÃ¡ conter o seu valor, apenas sua referÃªncia!
<br/>
Veja o exemplo a seguir

```js
const ğŸš— = ["ğŸ’º", "ğŸ’º", "ğŸ’º", "ğŸ’º"]
const ğŸš“ = ["ğŸ’º", "ğŸ’º", "ğŸ’º", "ğŸ’º"]
const ğŸš˜ = ğŸš—

console.log(ğŸš“ === ğŸš—) // false
console.log(ğŸš˜ === ğŸš—) // true
````

  Vamos voltar um pouco no texto "esta nova variÃ¡vel nÃ£o irÃ¡ conter o seu valor, apenas sua referÃªncia!". Calma aÃ­, se nÃ£o vai ter o valor, como o javascript conseguiu comparar o ğŸš˜ com o ğŸš—? E porque que ğŸš“ quando comparado com ğŸš—, o javascript nos diz que Ã© "diferente"? A resposta Ã© simples, comparaÃ§Ã£o por referÃªncia! assim como informaÃ§Ãµes primitivas que sÃ£o copiadas e comparadas por valor, as nÃ£o primitivas sÃ£o copiadas e comparadas por referÃªncia

## Como o javascript usa essa ReferÃªncia?

ReferÃªncias sÃ£o alocadas em um espaÃ§o na memÃ³ria do seu computador, e quando nÃ³s comparamos duas informaÃ§Ãµes nÃ£o primitivas, por exemplo um objeto, o Javascript compara seu endereÃ§o na memÃ³ria e nÃ£o seu conteÃºdo. Vejamos mais um exemplo 

```js
const ğŸ‘©â€âš•ï¸ = {
  nome: "Bia",
  idade: 28
};

const ğŸ‘©â€ğŸ³ = ğŸ‘©â€âš•ï¸;


console.log(ğŸ‘©â€âš•ï¸.nome); // Bia

ğŸ‘©â€ğŸ³.nome = "Patricia";

console.log(ğŸ‘©â€âš•ï¸.nome); // Patricia
console.log(ğŸ‘©â€ğŸ³.nome); // Patricia
```

  Ao definirmos o nome de ğŸ‘©â€ğŸ³ para Patricia, o nome de ğŸ‘©â€âš•ï¸ tambÃ©m muda! Isso acontece porque o conteÃºdo de ğŸ‘©â€ğŸ³ Ã© uma REFERENCIA ao conteÃºdo de ğŸ‘©â€âš•ï¸, entÃ£o qualquer mudanÃ§a que haja, em qualquer referÃªncia, o <code>Objeto</code>, <code>Array</code>, <code>FunÃ§Ã£o</code> original serÃ¡ afetada.

## Porque saber disso Ã© tÃ£o importante?

  Se vocÃª usa React a um tempo ou por acaso jÃ¡ se preocupou com problemas de performance no seu aplicativo, temos diversos hooks e funcionalidades que ajudam na performance do nosso programa, uma funcionalidade importante seria a array de dependÃªncias do <code>useEffect()</code>, se caso vocÃª colocar uma array ou objeto como dependÃªncia, a sua pÃ¡gina nÃ£o vai funcionar corretamente, pelo <code>useEffect()</code> comparar nÃ£o primitivos com sua referÃªncia. Um outro exemplo Ã© o hook <code>useCallback()</code>, utilizado para memorizaÃ§Ã£o de funcÃµes, que comparam com o seu real conteÃºdo, previnindo a criaÃ§Ã£o de uma funÃ§Ã£o toda renderizaÃ§Ã£o. Caso queira um post falando sobre, deixe-me saber! 
