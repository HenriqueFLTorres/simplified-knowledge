---
title: "Referência e Valor: Por que você deve saber a diferença"
postImage: "https://images.unsplash.com/photo-1512998844734-cd2cca565822?crop=entropy&cs=tinysrgb&fm=jpg&ixlib=rb-1.2.1&q=80&raw_url=true&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1921"
postedOn: "5 25 2022 17:26"
editedOn: "5 25 2022 17:26"
postTags: [ "JavaScript" ]
readTimeInMinutes: "3"
postLanguage: "PT"
postURL: "referencia-vs-valor"
alternativeLanguageURL: "reference-vs-value"
---


import Code from "../../components/Code";
import Highlight from "../../components/Highlight";
import { Link } from "@remix-run/react";
import mainImage from "~/public/images/ReferenceVsValue.jpg"
import Warning from "../../components/Warning"

## {attributes.title}

<Link to={`/blog/${attributes.alternativeLanguageURL}`}><div>English Article</div></Link>

<img src={mainImage} alt="" title="Imagem de David Jorre" className="MainImage" />

<Warning>Nos exemplos a seguir são utilizados emojis para nomear variáveis e não devem ser replicados, caso contrário, o seu código retornará um erro de síntaxe.</Warning>

Se por algum motivo você tentou comparar <Code>objetos</Code> ou <Code>arrays</Code> em JavaScript, você provavelmente ficou confuso, porque eles não eram os mesmos apesar de ter um valor/conteúdo idêntico. <br/>

Isso acontece porque o JavaScript compara tipos não primitivos com sua <Highlight>referência</Highlight> e não com seu valor real, e não saber disso pode causar dor de cabeça.

### Cópia por Valor <br/>

Tipos de dados primitivos como <Code>String</Code>, <Code>Number</Code>, <Code>Boolean</Code>, <Code>undefined</Code>, <Code>null</Code>, são marcados como tipos <Highlight>Valor</Highlight>, porque, quando copiamos sua informação ou valor para alguma outra variável, essa nova variável copiará seu valor.

Veja o exemplo a seguir.

```js
let 🍎 = "Maçã"
deixe 💰 = 0

let 🍏 = 🍎 // "Maçã"
deixe 👜 = 💰 // 0

console.log(🍏 === 🍎) // true
console.log(👜 === 💰) // true
```

Ao comparar as novas variáveis usando <Code>console.log()</Code>, ele retornará <Code>true</Code>, pois o JavaScript compara as primitivas de acordo com seu conteúdo.

### Cópia por Referência

Por outro lado, os não primitivos, <Code>Array</Code>, <Code>Object</Code> e <Code>Function</Code>, são marcados como tipo de <Highlight>Referência</Highlight> . Porque, quando definimos uma nova variável com suas informações, essa nova variável terá sua referência e não seu valor.

<br />
Veja o exemplo a seguir

```js
const 🚗 = [💺, 💺, 💺, 💺]
const 🚓 = [💺, 💺, 💺, 💺]
const 🚘 = 🚗

console.log(🚓 === 🚗) // false
console.log(🚘 === 🚗) // true
```

Vamos voltar a algumas linhas do texto <Highlight>"esta nova variável terá sua referência e não seu valor"</Highlight>. Mas, se não terá o valor, como o javascript conseguiu comparar o 🚘 com o 🚗? E por que 🚓 quando comparado a 🚗, JavaScript nos diz que é "diferente"? <br/>

A resposta é simples, comparação por <Highlight>referência</Highlight>! Os tipos de dados primitivos são copiados e comparados por valor, e os não primitivos são copiados e comparados por referência.

### Ok, mas o que é Referência?

Referências são endereços alocados na memória do seu computador, e quando comparamos duas informações não primitivas, por exemplo, um <Code>objeto</Code>, o JavaScript compara seu endereço de memória e não seu conteúdo. Vamos ver mais um exemplo.

```js
const 👩‍⚕️ = {
  nome: "Bia",
  idade: 28
};

const 👩‍🍳 = 👩‍⚕️;

console.log(👩‍⚕️.nome); // Bia

👩‍🍳.nome = "Patricia";

console.log(👩‍⚕️.nome); // Patricia
console.log(👩‍🍳.nome); // Patricia
```

Quando definimos o nome de 👩‍🍳 para Patricia, o nome de 👩‍⚕️ também muda! Isso porque o conteúdo de 👩‍🍳 é uma <Highlight>referência</Highlight> ao conteúdo de 👩‍⚕️, portanto, quaisquer alterações em uma cópia de não primitivo, <Code>Object</Code>, <Code>Array</Code>, <Code >Function</Code> o original será afetado.

### Por que saber isso é importante?

Se você já usa o React há algum tempo, temos vários hooks e recursos que ajudam no desempenho do nosso programa, e um importante é o array de dependência do <Code>useEffect()</Code>. Se você colocar um array ou objeto como uma dependência, sua página não funcionará corretamente, e isso é porque <Code>useEffect()</Code> está comparando não primitivos com sua <Highlight>referência</Highlight>. <br/>

Outro exemplo é o <Code>useCallback()</Code>, usado para memorizar funções e não apenas comparar com sua referência, evitando a criação de outra função idêntica em cada renderização. Caso queira um post falando sobre isso, me deixe saber! <br/>

Portanto, saber a diferença entre <Highlight>referência</Highlight> e real <Highlight>valor</Highlight> é fundamental para aprender hooks avançados no React como <Code>useEffect()</Code>, <Code>useCallback()</Code> e <Code>useMemo()</Code>.

### <Highlight>Lembre-se!</Highlight>

• Os copiados por valor são primitivos. <br/>
• Os copiados por referência são os não primitivos. <br/>
• Ao comparar não primitivos idênticos, eles retornam <Code>false</Code> pelo seu tipo de comparação por <Highlight>referência</Highlight>. <br/>

• Copiados por valor → <Code>String</Code>, <Code>Number</Code>, <Code>Boolean</Code>, <Code>undefined</Code> e <Code>null</Code>. <br/>
• Copiados por referência → <Code>Array</Code>, <Code>Object</Code> e <Code>Function</Code>.
