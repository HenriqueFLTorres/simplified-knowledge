---
title: "ReferÃªncia e Valor: Por que vocÃª deve saber a diferenÃ§a"
englishVersion: "reference-vs-value"
posted: "5 20 2022"
edited: "5 20 2022"
mainImage: ""
---

import Code from "../../components/Code";
import Highlight from "../../components/Highlight";
import { Link } from "@remix-run/react";

## {attributes.title}

<Link to={`/blog/${attributes.englishVersion}`}><div>English Article</div></Link>

Se por algum motivo vocÃª tentou comparar <Code>objetos</Code> ou <Code>arrays</Code> em JavaScript, vocÃª provavelmente ficou confuso, porque eles nÃ£o eram os mesmos apesar de ter um valor/conteÃºdo idÃªntico. <br/>

Isso acontece porque o JavaScript compara tipos nÃ£o primitivos com sua <Highlight>referÃªncia</Highlight> e nÃ£o com seu valor real, e nÃ£o saber disso pode causar dor de cabeÃ§a.

### Copiar por Valor <br/>

Tipos de dados primitivos como <Code>String</Code>, <Code>Number</Code>, <Code>Boolean</Code>, <Code>undefined</Code>, <Code>null</Code>, sÃ£o marcados como tipos <Highlight>Valor</Highlight>, porque, quando copiamos sua informaÃ§Ã£o ou valor para alguma outra variÃ¡vel, essa nova variÃ¡vel copiarÃ¡ seu valor.

Veja o exemplo a seguir.

```js
let ğŸ = "MaÃ§Ã£"
deixe ğŸ’° = 0

let ğŸ = ğŸ // "MaÃ§Ã£"
deixe ğŸ‘œ = ğŸ’° // 0

console.log(ğŸ === ğŸ) // true
console.log(ğŸ‘œ === ğŸ’°) // true
```

Ao comparar as novas variÃ¡veis usando <Code>console.log()</Code>, ele retornarÃ¡ <Code>true</Code>, pois o JavaScript compara as primitivas de acordo com seu conteÃºdo.

### Copiar por referÃªncia

Por outro lado, os nÃ£o primitivos, <Code>Array</Code>, <Code>Object</Code> e <Code>Function</Code>, sÃ£o marcados como tipo de <Highlight>ReferÃªncia</Highlight> . Porque, quando definimos uma nova variÃ¡vel com suas informaÃ§Ãµes, essa nova variÃ¡vel terÃ¡ sua referÃªncia e nÃ£o seu valor.

<br />
Veja o exemplo a seguir

```js
const ğŸš— = [ğŸ’º, ğŸ’º, ğŸ’º, ğŸ’º]
const ğŸš“ = [ğŸ’º, ğŸ’º, ğŸ’º, ğŸ’º]
const ğŸš˜ = ğŸš—

console.log(ğŸš“ === ğŸš—) // false
console.log(ğŸš˜ === ğŸš—) // true
```

Vamos voltar a algumas linhas do texto <Highlight>"esta nova variÃ¡vel terÃ¡ sua referÃªncia e nÃ£o seu valor"</Highlight>. Mas, se nÃ£o terÃ¡ o valor, como o javascript conseguiu comparar o ğŸš˜ com o ğŸš—? E por que ğŸš“ quando comparado a ğŸš—, JavaScript nos diz que Ã© "diferente"? <br/>

A resposta Ã© simples, comparaÃ§Ã£o por <Highlight>referÃªncia</Highlight>! Os tipos de dados primitivos sÃ£o copiados e comparados por valor, e os nÃ£o primitivos sÃ£o copiados e comparados por referÃªncia.

### Ok, mas o que Ã© ReferÃªncia?

ReferÃªncias sÃ£o endereÃ§os alocados na memÃ³ria do seu computador, e quando comparamos duas informaÃ§Ãµes nÃ£o primitivas, por exemplo, um <Code>objeto</Code>, o JavaScript compara seu endereÃ§o de memÃ³ria e nÃ£o seu conteÃºdo. Vamos ver mais um exemplo.

```js
fsdfsadfsdfads  
```

Quando definimos o nome de ğŸ‘©â€ğŸ³ para Patricia, o nome de ğŸ‘©â€âš•ï¸ tambÃ©m muda! Isso porque o conteÃºdo de ğŸ‘©â€ğŸ³ Ã© uma <Highlight>referÃªncia</Highlight> ao conteÃºdo de ğŸ‘©â€âš•ï¸, portanto, quaisquer alteraÃ§Ãµes em uma cÃ³pia de nÃ£o primitivo, <Code>Object</Code>, <Code>Array</Code>, <Code >Function</Code> o original serÃ¡ afetado.

### Por que saber isso Ã© importante?

Se vocÃª jÃ¡ usa o React hÃ¡ algum tempo, temos vÃ¡rios hooks e recursos que ajudam no desempenho do nosso programa, e um importante Ã© o array de dependÃªncia do <Code>useEffect()</Code>. Se vocÃª colocar um array ou objeto como uma dependÃªncia, sua pÃ¡gina nÃ£o funcionarÃ¡ corretamente, e isso Ã© porque <Code>useEffect()</Code> estÃ¡ comparando nÃ£o primitivos com sua <Highlight>referÃªncia</Highlight>. <br/>

Outro exemplo Ã© o <Code>useCallback()</Code>, usado para memorizar funÃ§Ãµes, comparando-as com seu conteÃºdo, evitando a criaÃ§Ã£o de outra funÃ§Ã£o idÃªntica em cada renderizaÃ§Ã£o. Caso queira um post falando sobre isso, me deixe saber!

### <Highlight>Lembre-se!</Highlight>

â€¢ Os copiados por valor sÃ£o primitivos. <br/>
â€¢ Os copiados por referÃªncia sÃ£o os nÃ£o primitivos. <br/>
â€¢ Ao comparar nÃ£o primitivos idÃªnticos, eles retornam <Code>false</Code> pelo seu tipo de cÃ³pia por <Highlight>referÃªncia</Highlight>. <br/>

â€¢ Copiados por valor â†’ <Code>String</Code>, <Code>Number</Code>, <Code>Boolean</Code>, <Code>undefined</Code> e <Code>null</Code>. <br/>
â€¢ Copiados por referÃªncia â†’ <Code>Array</Code>, <Code>Object</Code> e <Code>Function</Code>.
