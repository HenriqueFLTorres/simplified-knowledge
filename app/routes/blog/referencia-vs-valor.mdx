---
title: "ReferÃªncia e Valor: Por que vocÃª deve saber a diferenÃ§a"
postImage: "https://images.unsplash.com/photo-1512998844734-cd2cca565822?crop=entropy&cs=tinysrgb&fm=jpg&ixlib=rb-1.2.1&q=80&raw_url=true&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1921"
postedOn: "5 25 2022 17:26"
editedOn: "5 25 2022 17:26"
postTags: [ "JavaScript" ]
readTimeInMinutes: "3"
postLanguage: "PT"
postURL: "referencia-vs-valor"
alternativeLanguageURL: "reference-vs-value"
---


import Code from "../../components/Code";
import Highlight from "../../components/Highlight";
import { Link } from "@remix-run/react";
import mainImage from "~/public/images/ReferenceVsValue.jpg"
import Warning from "../../components/Warning"

## {attributes.title}

<Link to={`/blog/${attributes.alternativeLanguageURL}`}><div>English Article</div></Link>

<img src={mainImage} alt="" title="Imagem de David Jorre" className="MainImage" />

<Warning>Nos exemplos a seguir sÃ£o utilizados emojis para nomear variÃ¡veis e nÃ£o devem ser replicados, caso contrÃ¡rio, o seu cÃ³digo retornarÃ¡ um erro de sÃ­ntaxe.</Warning>

Se por algum motivo vocÃª tentou comparar <Code>objetos</Code> ou <Code>arrays</Code> em JavaScript, vocÃª provavelmente ficou confuso, porque eles nÃ£o eram os mesmos apesar de ter um valor/conteÃºdo idÃªntico. <br/>

Isso acontece porque o JavaScript compara tipos nÃ£o primitivos com sua <Highlight>referÃªncia</Highlight> e nÃ£o com seu valor real, e nÃ£o saber disso pode causar dor de cabeÃ§a.

### CÃ³pia por Valor <br/>

Tipos de dados primitivos como <Code>String</Code>, <Code>Number</Code>, <Code>Boolean</Code>, <Code>undefined</Code>, <Code>null</Code>, sÃ£o marcados como tipos <Highlight>Valor</Highlight>, porque, quando copiamos sua informaÃ§Ã£o ou valor para alguma outra variÃ¡vel, essa nova variÃ¡vel copiarÃ¡ seu valor.

Veja o exemplo a seguir.

```js
let ğŸ = "MaÃ§Ã£"
deixe ğŸ’° = 0

let ğŸ = ğŸ // "MaÃ§Ã£"
deixe ğŸ‘œ = ğŸ’° // 0

console.log(ğŸ === ğŸ) // true
console.log(ğŸ‘œ === ğŸ’°) // true
```

Ao comparar as novas variÃ¡veis usando <Code>console.log()</Code>, ele retornarÃ¡ <Code>true</Code>, pois o JavaScript compara as primitivas de acordo com seu conteÃºdo.

### CÃ³pia por ReferÃªncia

Por outro lado, os nÃ£o primitivos, <Code>Array</Code>, <Code>Object</Code> e <Code>Function</Code>, sÃ£o marcados como tipo de <Highlight>ReferÃªncia</Highlight> . Porque, quando definimos uma nova variÃ¡vel com suas informaÃ§Ãµes, essa nova variÃ¡vel terÃ¡ sua referÃªncia e nÃ£o seu valor.

<br />
Veja o exemplo a seguir

```js
const ğŸš— = [ğŸ’º, ğŸ’º, ğŸ’º, ğŸ’º]
const ğŸš“ = [ğŸ’º, ğŸ’º, ğŸ’º, ğŸ’º]
const ğŸš˜ = ğŸš—

console.log(ğŸš“ === ğŸš—) // false
console.log(ğŸš˜ === ğŸš—) // true
```

Vamos voltar a algumas linhas do texto <Highlight>"esta nova variÃ¡vel terÃ¡ sua referÃªncia e nÃ£o seu valor"</Highlight>. Mas, se nÃ£o terÃ¡ o valor, como o javascript conseguiu comparar o ğŸš˜ com o ğŸš—? E por que ğŸš“ quando comparado a ğŸš—, JavaScript nos diz que Ã© "diferente"? <br/>

A resposta Ã© simples, comparaÃ§Ã£o por <Highlight>referÃªncia</Highlight>! Os tipos de dados primitivos sÃ£o copiados e comparados por valor, e os nÃ£o primitivos sÃ£o copiados e comparados por referÃªncia.

### Ok, mas o que Ã© ReferÃªncia?

ReferÃªncias sÃ£o endereÃ§os alocados na memÃ³ria do seu computador, e quando comparamos duas informaÃ§Ãµes nÃ£o primitivas, por exemplo, um <Code>objeto</Code>, o JavaScript compara seu endereÃ§o de memÃ³ria e nÃ£o seu conteÃºdo. Vamos ver mais um exemplo.

```js
const ğŸ‘©â€âš•ï¸ = {
  nome: "Bia",
  idade: 28
};

const ğŸ‘©â€ğŸ³ = ğŸ‘©â€âš•ï¸;

console.log(ğŸ‘©â€âš•ï¸.nome); // Bia

ğŸ‘©â€ğŸ³.nome = "Patricia";

console.log(ğŸ‘©â€âš•ï¸.nome); // Patricia
console.log(ğŸ‘©â€ğŸ³.nome); // Patricia
```

Quando definimos o nome de ğŸ‘©â€ğŸ³ para Patricia, o nome de ğŸ‘©â€âš•ï¸ tambÃ©m muda! Isso porque o conteÃºdo de ğŸ‘©â€ğŸ³ Ã© uma <Highlight>referÃªncia</Highlight> ao conteÃºdo de ğŸ‘©â€âš•ï¸, portanto, quaisquer alteraÃ§Ãµes em uma cÃ³pia de nÃ£o primitivo, <Code>Object</Code>, <Code>Array</Code>, <Code >Function</Code> o original serÃ¡ afetado.

### Por que saber isso Ã© importante?

Se vocÃª jÃ¡ usa o React hÃ¡ algum tempo, temos vÃ¡rios hooks e recursos que ajudam no desempenho do nosso programa, e um importante Ã© o array de dependÃªncia do <Code>useEffect()</Code>. Se vocÃª colocar um array ou objeto como uma dependÃªncia, sua pÃ¡gina nÃ£o funcionarÃ¡ corretamente, e isso Ã© porque <Code>useEffect()</Code> estÃ¡ comparando nÃ£o primitivos com sua <Highlight>referÃªncia</Highlight>. <br/>

Outro exemplo Ã© o <Code>useCallback()</Code>, usado para memorizar funÃ§Ãµes e nÃ£o apenas comparar com sua referÃªncia, evitando a criaÃ§Ã£o de outra funÃ§Ã£o idÃªntica em cada renderizaÃ§Ã£o. Caso queira um post falando sobre isso, me deixe saber! <br/>

Portanto, saber a diferenÃ§a entre <Highlight>referÃªncia</Highlight> e real <Highlight>valor</Highlight> Ã© fundamental para aprender hooks avanÃ§ados no React como <Code>useEffect()</Code>, <Code>useCallback()</Code> e <Code>useMemo()</Code>.

### <Highlight>Lembre-se!</Highlight>

â€¢ Os copiados por valor sÃ£o primitivos. <br/>
â€¢ Os copiados por referÃªncia sÃ£o os nÃ£o primitivos. <br/>
â€¢ Ao comparar nÃ£o primitivos idÃªnticos, eles retornam <Code>false</Code> pelo seu tipo de comparaÃ§Ã£o por <Highlight>referÃªncia</Highlight>. <br/>

â€¢ Copiados por valor â†’ <Code>String</Code>, <Code>Number</Code>, <Code>Boolean</Code>, <Code>undefined</Code> e <Code>null</Code>. <br/>
â€¢ Copiados por referÃªncia â†’ <Code>Array</Code>, <Code>Object</Code> e <Code>Function</Code>.
