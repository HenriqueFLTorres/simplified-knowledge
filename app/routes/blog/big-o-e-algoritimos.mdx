---
title: 'Clean Code: Controvérsias do DRY code e o Monstro da Abstração errada'
shortDescription: 'Não é surpresa que tenhamos muitos princípios de programação que nos ajudam a criar aplicativos poderosos, mas devemos segui-los à risca?'
postImage: 'https://images.unsplash.com/photo-1517487728715-4713140dcac0?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2070&q=80'
postedOn: '6 2 2022 20:10'
editedOn: '6 2 2022 20:10'
tags: ['Computer Science']
readTimeInMinutes: '3'
englishLanguage: true
postURL: 'algorithms-and-big-o'
alternativeLanguageURL: 'dry-code-controversies'
---

import { CodeFragment, Highlight } from '@components/shared';
import { Link } from '@remix-run/react';

## {attributes.title}

<Link to={`/blog/${attributes.alternativeLanguageURL}`}>
  <div>English Article</div>
</Link>

<img
  src={attributes.postImage}
  alt=''
  title='Imagem de David Jorre pelo Unsplash'
  className='MainImage'
/>

se você é uma pessoa comum como eu, provavelmente tem uma rotina para o seu dia, passos que segue todos os dias. Algumas pessoas gostam de acordar e
tomar uma xícara de café, e outros gostam de escovar os dentes logo de manhã e depois tomar café da manhã, ir à academia, tomar banho
e assim por diante. Então, o que isso tem a ver com algoritmos ou notações Big O? Bem, nada com Big O por enquanto, mas algoritmos são como nossas rotinas,
um conjunto de instruções, quando você abre o Twitter, por exemplo, eles têm um algoritmo para pesquisar tendências e os tweets mais quentes, ou quando você pesquisa
para algo no Google, eles têm um conjunto de instruções para lidar com sua entrada.
    
    ## Que problema eles resolvem
    
  Eles fazem parte do nosso dia e não necessariamente “resolvem” um problema, mas podemos conseguir o que queremos. Podemos pesquisar um e-mail usando um algoritmo de pesquisa,
podemos encontrar uma pessoa no Instagram pelo nome ou podemos fazer coisas importantes como pousar um foguete na lua. Nós os usamos para fazer coisas pesadas que
computadores estão fazendo muito rápido.

   ## O que faz um bom algoritmo
 
 Primeiro, precisamos pensar no que é uma boa solução para você, correto? Rapidez? Normalmente, tendemos a preferir os dois, mas especificamente a velocidade, podemos medi-la
através do Big O(n). E antes que você pensasse que temos cronômetros apontando para os computadores executando algoritmos diferentes, essa é uma maneira estúpida de medir
eles, porque existem muitos fatores como velocidade do processador, otimização do compilador ou linguagem de programação. Em vez disso, temos Big O(n), que mede a
velocidade do algoritmo de acordo com o tamanho da entrada <Highlight>avaliando seu pior cenário</Highlight>.

## Como o tamanho da entrada afeta o desempenho

  É inegável que pesquisar em uma lista de 500 mil nomes de pessoas do Facebook é mais pesado do que uma lista de 2 mil membros do discord, mas como
especificamente, isso afeta o algoritmo? Bem, dependendo da sua abordagem, ou do tipo de algoritmo escolhido, o algoritmo pode perder muito tempo pesquisando
nomes que não são importantes para a pesquisa, se você pressionar T (20ª letra do alfabeto), por exemplo, a pessoa que você está tentando encontrar é muito mais provável
estar próximo ao final da lista e depois ao início, e comparando as abordagens de busca linear e binária, podemos dizer com confiança que a busca binária é muito
mais rápido que o linear.

  Usando uma lista de 500k de nomes ordenados alfabeticamente, usando a pesquisa linear (Big O(n)), se nosso destino for o sobrenome da lista (pior cenário), precisaríamos
percorrer 499.999 nomes para chegar ao nosso alvo. Por exemplo, se fosse 1 ms para cada nome que passaríamos, os algoritmos levariam cerca de 8
minutos para completar a busca, e se usarmos busca binária (Big O(log n)), o algoritmo levaria 19 tentativas no máximo resultando em 19ms

### Como posso saber o que é Big O no meu algoritmo?

  Como eu disse no parágrafo anterior, a velocidade do seu algoritmo está relacionada ao tamanho de entrada dele, e o n dentro dos parênteses Big O(n) é o
equação do seu algoritmo, um pouco confuso né? Então, de uma maneira simples de explicar, o n é como a expressão <CodeFragment>time * n</CodeFragment>,
em uma pesquisa linear, o tempo é multiplicado pelo número de itens ou comprimento de sua matriz que você está pesquisando. Na busca binária, o Big O é
<CodeFragment>log n</CodeFragment> "basicamente significa que o tempo sobe linearmente enquanto o n sobe exponencialmente", saiba mais aqui
(https://stackoverflow.com/a/2307330/17776680).

### E se eu tiver mais de um tipo de algoritmo?

  Como dito anteriormente, o Big o leva o pior cenário possível, então, por exemplo, se o Facebook usou diferentes tipos de algoritmos na pesquisa com base no tipo de usuário,
se o algoritmo linear fosse para usuários gratuitos e a busca binária para usuários premium, o pior cenário seria a busca linear (não porque eles são os
mais comuns). Portanto, nossa eficiência de tempo seria Big O(n)